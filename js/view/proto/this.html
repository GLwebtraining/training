<h3>Ключевое слово this</h3>
<p>this – это именно ключевое слово, а не имя переменной или свойства. Синтаксис JavaScript не допускает возможность присваивания значений элементу this.</p>
<p>this не привязывается к объекту, а зависит от контекста вызова.</p>
<ul>
	<li>
		<p><strong>Глобальная область видимости</strong></p>
		<code>this;</code>
		<p>Ссылается на глобальный объект</p>
		<p>В JavaScript в качестве глобального объекта для всего кода, содержащегося в соответствующем ему окне брfузера, служит объект Window. Этот глобальный объект имеет свойство window, ссылающееся на сам
			объект, которое можно использовать вместо ключевого слова this для ссылки на
			глобальный объект. Объект Window определяет базовые глобальные свойства, такие как parseInt и Math, а также глобальные клиентские свойства, такие как
			navigator и screen.</p>
		<p><code>console.log(this); // -> window</code></p>
	</li>
	<li>
		<p><strong>Вызов функции</strong></p>
		<code>foo();</code>
		<p>Внутри функции this ссылается на глобальный объект.</p>
		<p>Когда функция вызывается как функция, а не как метод, ключевое слово this
			ссылается на глобальный объект. Это верно даже для функ
			ций (если они вызываются как функции), вложенных в методы, которые в свою
			очередь вызываются как методы. Ключевое слово this имеет одно значение в объ
			емлющей функции и ссылается на глобальный объект в теле вложенной функции.</p>
		<p>
			<code>function foo(){</code>
			<br />
			<code>&nbsp;&nbsp;console.log(this); // -> window</code>
			<br />
			<code>}</code>
		</p>
	</li>
	<li>
		<p><strong>Вызов метода</strong></p>
		<code>test.foo();</code>
		<p>Внутри метода this ссылается на test.</p>
		<p>Любая функция, вызываемая
			как метод, получает в свое распоряжение дополнительный неявный аргумент –
			объект, посредством которого эта функция была вызвана. Как правило, методы
			выполняют некоторые действия над этим объектом, таким образом, синтаксис
			вызова методов наглядно отражает тот факт, что функция оперирует объектом.</p>
		<p>
			<code>var test = {</code>
			<br />
			<code>&nbsp;&nbsp;foo: function(){</code>
			<br />
			<code>&nbsp;&nbsp;&nbsp;&nbsp;console.log(this); // -> test</code>
			<br />
			<code>&nbsp;&nbsp;}</code>
			<br />
			<code>}</code>
		</p>
	</li>
	<li>
		<p><strong>Вызов конструктора</strong></p>
		<p>Конструктор – это функция, которая выполняет инициализацию свойств объекта и предназначена для использования совместно с инструкцией new.</p>
		<code>new foo();</code>
		<p>Инструкция new создает новый объект Function, после чего вызывает функцию-конструктор, передавая ей вновь созданный объект в качестве значения ключевого слова this.</p>
		<p>Т.е. если перед вызовом функции присутствует ключевое слово new то данная функция будет действовать как конструктор. Внутри такой функции this будет указывать на новый созданный Object.</p>
		<p>
			<code>function foo(){</code>
			<br />
			<code>&nbsp;&nbsp;console.log(this);</code>
			<br />
			<code>}</code>
			<br />
			<code>new foo();</code>
		</p>
	</li>
	<li>
		<p><strong>Переопределение. Методы call() и apply()</strong></p>
		<p>В ECMAScript есть два метода, определенные для всех функций, – call() и apply(). Эти методы позволяют вызывать функцию так, будто она является методом некоторого объекта. Первый аргумент методов call() и apply() – это объект, для которого выполняется функция; этот аргумент становится значением ключевого слова this в теле функции. Все оставшиеся аргументы call() – это значения, передаваемые вызываемой функции. Метод apply() похож на метод call(), за исключением того, что передаваемые функции аргументы задаются в виде массива.</p>
		<code>foo.apply(obj, [args]) <br /> foo.call(obj, args)</code>
		<p>Таким образом, когда мы используем методы call или apply из Function.prototype, то внутри вызваемой функции this явным образом будет присвоено значение первого передаваемого параметра.</p>
		<p>
			<code>var results = {};</code>
			<br />
			<code>function foo(a, b){</code>
			<br />
			<code>&nbsp;&nbsp;this.c = a + b;</code>
			<br />
			<code>}</code>
			<br />
			<code>foo.call(results, 1, 2);</code>
			<br />
			<code>foo.apply(results, [1, 2]);</code>
			<br />
			<code>console.log(results.c);</code>
		</p>
	</li>
</ul>
