<h3>Інструкції</h3>
<p><strong>Інструкції-вирази</strong></p>
<p>Найпростіший вид інструкцій в JavaScript - це вирази, що призводять до деяких динамічних дій.
Основна категорія інструкцій-виразів - це інструкції присвоювання. Наприклад:</p>
<pre>s = 'Hello ' + name;
i *= 3;
counter++;
delete o.x;</pre>
<p>Кожен рядок у цих прикладах завершується крапкою з комою.</p>
<p>Складні інструкції - в чистому вигляді практично не використовуються.</p>
<p>У JavaScript є також можливість об'єднання декількох інструкцій в одну інструкцію або в блок інструкцій. Це робиться простим укладанням будь-якої кількості інструкцій у фігурні дужки.
Таким чином, наступні рядки розглядаються як одна інструкція і можуть використовуватися скрізь, де інтерпретатор JavaScript вимагає наявності єдиної інструкції:</p>

<pre>{
&nbsp;&nbsp;x = Math.PI;
&nbsp;&nbsp;cx = Math.cos(x);
&nbsp;&nbsp;alert("cos(" + x + ") = " + cx);
}
</pre>

<p>Зверніть увагу, що хоча блок інструкцій діє як одна інструкція, він не завершується крапкою з комою. Окремі інструкції всередині блоку завершуються крапкою з комою, однак сам блок - ні.</p>
<ul>
	<li>
		<strong>Інструкція if / else if</strong>
		<p>
		Інструкція if - це базова керуюча інструкція, що дозволяє інтерпретатору JavaScript приймати рішення або, точніше, виконувати інструкції
в залежності від виконання:</p>

<pre>if (вираз)
&nbsp;&nbsp;инструкция</pre>

<p>Конструкція else виконується тоді, коли вираз дорівнює false. Її синтаксис:</p>

<pre>if (выражение)
&nbsp;&nbsp;инструкция1
else
&nbsp;&nbsp;инструкция2</pre>

<h4>Інструкція else if</h4>
<pre>
if (n == 1) {} // Виконуємо блок коду 1
else if (n == 2) {} // Виконуємо блок коду 2
else if (n == 3) {} // Виконуємо блок коду 3
else {} // Якщо всі інші умови else не виконуються, виконуємо блок 4</pre>
	</li>
	<li>
		<strong>Інструкція switch</strong>
		<p>Синтаксис:</p>
		<pre>switch(n) {
		
		&nbsp;&nbsp;case 1: // Виконується, якщо n == 1
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 1
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;case 2: // Виконується, якщо n == 2
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 2.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;case 3: // Виконується, якщо n == 3
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 3.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		&nbsp;&nbsp;default: // Якщо все інше не підходить...
		
		&nbsp;&nbsp;&nbsp;&nbsp;// Виконуємо блок коду 4.
		
		&nbsp;&nbsp;&nbsp;&nbsp;break; // Тут зупиняємося
		
		}</pre>
<p>Зверніть увагу на ключове слово break в кінці кожного блоку case. Інструкція break призводить до передачі управління
в кінець інструкції switch або циклу. Конструкції case в інструкції switch задають тільки початкову точку виконуваного коду, але не задають ніяких кінцевих точок.
У разі відсутності інструкцій break інструкція switch починає
виконання блоку коду з мітки case, відповідної значенню виразу,
і продовжує виконання до тих пір, поки не дійде до кінця блоку.</p>

<p>Якщо мітка default: відсутня, то інструкція switch повністю пропускається. Зверніть увагу, що в попередніх прикладах мітка default: вказана
в кінці тіла інструкції switch після всіх міток case.</p>
	</li>
	<li>
		<strong>Інструкція while</strong>
		<p>Так само як інструкція if є базовою керуючої інструкцією, що дозволяє інтерпретатору JavaScript приймати рішення і виконувати повторювані дії. Вона має наступний синтаксис: </p>
<pre>while (вираз)
інструкція</pre>
<p>
Інструкція while починає роботу з обчислення виразу. Якщо результатом є false, інтерпретатор JavaScript переходить до наступної інструкції програми, а якщо true, то виконується інструкція, що утворює тіло циклу, і вираз обчислюється знову.
І знову, якщо значення дорівнює false, інтерпретатор JavaScript переходить до наступної інструкції програми, в іншому випадку він виконує інструкцію знову. Цикл триває, поки вираз не стане рівним false, тоді інструкція while завершить роботу і JavaScript піде далі. За допомогою синтаксису <code>while(true)</code> можна створити безкінечный цикл.</p>
	</li>
	<li>
		<strong>Цикл do/while</strong>
		<p>Цикл do/while в чомусь схожий на цикл while, за винятком того, що вираз циклу перевіряється в кінці, а не на початку циклу. Це означає, що тіло циклу
завжди виповнюється хоча б один раз. Синтаксис:</p>
<pre>do
інструкція
while (вираз);</pre>
	</li>
	<li>
		<strong>Інструкція for</strong>
		<p>Синтаксис циклу for: </p>
		<pre>for(ініціалізація; перевірка; інкремент)
		инструкция</pre>
	<p>
Ініціалізація, перевірка і оновлення - це три ключові операції, виконуваних зі змінною циклу; інструкція for робить ці три кроки явною частиною
синтаксису циклу. Це особливо полегшує розуміння дій, виконуваних циклом for, і запобігає таких помилок, як пропуск ініціалізації або
збільшення змінної циклу.</p>
	</li>
	<li>
		<strong>Інструкція for/in</strong>
		<p>Синтаксис: </p>
		<pre>for (змінна in об'єкт)
		інструкція</pre>
		<p>
Тут змінна повинна бути або ім'ям змінної, або інструкцією var,
оголошується змінна, або елементом масиву, або властивістю об'єкта
(т. е. має бути чимось, що може перебувати лівій частині вирази присвоювання). Параметр об'єкт - це ім'я об'єкта або вираз,
результатом якого є об'єкт. І як завжди, інструкція - це інструкція або блок інструкцій, що утворюють тіло циклу.</p>
	</li>
	<li>
		<strong>Інструкція break</strong>
		<p>Инструкция break приводит к немедленному выходу из самого внутреннего цикла или инструкции switch.
В циклах она обычно используется для преждевременного выхода в тех случаях, когда по какой-либо причине отпала необходимость доводить
выполнение цикла до конца. Когда в цикле имеются сложные условия выхода,
часто проще реализовать некоторые из этих условий с помощью инструкции
break, а не пытаться включить их все в одно выражение цикла.
<br />
<code>for(i = 0; i < a.length; i++) {</code>
<br />
<code>&nbsp;&nbsp;if (a[i] == target)</code>
<br />
<code>&nbsp;&nbsp;break;</code>
<br />
<code>}</code>
</p>
	</li>
	<li>
		<strong>Инструкция continue</strong>
		<p>Инструкция continue схожа с инструкцией break. Однако вместо выхода из цикла
continue запускает новую итерацию цикла</p>
	</li>
	<li>
		<strong>Инструкция var</strong>
		<p>Инструкция var позволяет явно объявить одну или несколько переменных. Инструкция имеет следующий синтаксис: <br />
<code>var имя_1 [ = значение_1] [ ,..., имя_n [= значение_n]]</code><br />
За ключевым словом var следует список объявляемых переменных через запятую; 
каждая переменная в списке может иметь специальное выражениеини-циализатор, указывающее ее начальное значение. Например: <br />
<code>var i;</code>
<br />
<code>var j = 0;</code>
<br />
<code>var p, q;</code>
<br />
<code>var greeting = "hello" + name;</code>
<br />
<code>var x = 2.34, y = Math.cos(0.75), r, theta;</code>
<br />
Инструкция var определяет каждую из перечисленных переменных путем создания свойства с этим именем в объекте вызова функции, в которой она находится,
или в глобальном объекте, если объявление находится не в теле функции. Свойство или свойства, создаваемые с помощью инструкции var, не могут быть удалены оператором delete.</p>
	</li>
	<li>
		<strong>Инструкция function</strong>
		<p>Инструкция function в JavaScript определяет функцию. Она имеет следующий
синтаксис: <br />
<code>function имя_функции([арг1 [,арг2 [..., аргn]]]) {</code>
<br />
<code>&nbsp;&nbsp;инструкции</code>
<br />
<code>}</code>
<br />
Здесь имя_функции – это имя определяемой функции. Оно должно быть идентификатором, а не строкой или выражением. 
За именем функции следует заключенный в скобки список имен аргументов, разделенных запятыми. 
Эти идентификаторы могут использоваться в теле функции для ссылки на значения аргументов, переданных при вызове функции.
<br />
Тело функции состоит из произвольного числа JavaScript-инструкций, заключенных в фигурные скобки. Эти инструкции не исполняются при определении
функции. Они компилируются и связываются с новым объектом функции для
исполнения при ее вызове с помощью оператора вызова (). Обратите внимание,
что фигурные скобки – это обязательная часть инструкции function. В отличие
от блоков инструкций в циклах while и других конструкциях, тело функции требует фигурных скобок, даже если оно состоит только из одной инструкции.</p>
	</li>
	<li>
		<strong>Инструкция return</strong>
		<p>Инструкция return может располагаться только в теле функции. Присутствие ее
в любом другом месте является синтаксической ошибкой. Когда выполняется
инструкция return, вычисляется выражение и его значение возвращается в качестве значения функции. Инструкция return прекращает исполнение функции,
даже если в теле функции остались другие инструкции. Инструкция return используется для возвращения значения следующим образом:
<br />
<code>function square(x) { return x*x; }</code>
<br />
Инструкция return может также использоваться без выражения, тогда она просто прерывает исполнение функции, не возвращая значение.
Если в функции выполняется инструкция return без выражения или если выполнение функции прекращается по причине достижения конца тела функции, значение выражения вызова функции оказывается неопределенным (undefined).</p>
	</li>
	<li>
		<strong>Инструкция throw</strong>
		<p>Исключение – это сигнал, указывающий на возникновение какой-либо исключительной ситуации или ошибки. Генерация исключения (throw) – это способ
просигнализировать о такой ошибке или исключительной ситуации. Перехва'
тить исключение (catch), значит, обработать его, т. е. предпринять действия,
необходимые или подходящие для восстановления после исключения. В JavaScript исключения генерируются в тех случаях, когда возникает ошибка времени выполнения, тогда программа явно генерирует его с помощью инструкции
throw. Исключения перехватываются с помощью инструкции try/catch/finally.
Инструкция throw имеет следующий синтаксис: <br />
<code>throw выражение;</code><br />
Результатом выражения может быть значение любого типа. Однако обычно это
объект Error или экземпляр одного из подклассов Error. Также бывает удобно использовать в качестве выражения строку, содержащую сообщение об ошибке
или числовое значение, обозначающее некоторый код ошибки. Вот пример кода,
в котором инструкция throw применяется для генерации исключения: <br />
<code>function factorial(x) {</code>
<br />
<code>&nbsp;&nbsp;// Если входной аргумент не является допустимым, генерируем исключение!</code>
<br />
<code>&nbsp;&nbsp;if (x < 0) throw new Error("x не может быть отрицательным");</code>
<br />
<code>&nbsp;&nbsp;// В противном случае вычисляем значение и нормальным образом выходим из функции</code>
<br />
<code>&nbsp;&nbsp;for(var f = 1; x > 1; f *= x, x--) /* пустое тело цикла */ ;</code>
<br />
<code>&nbsp;&nbsp;return f;</code>
<br />
<code>}</code>
<br />
Когда генерируется исключение, интерпретатор JavaScript немедленно прерывает нормальное исполнение программы и переходит к ближайшему обработчику исключений. В обработчиках исключений используется конструкция catch
инструкции try/catch/finally, описание которой приведено в следующем разделе. Если блок кода, в котором возникло исключение, не имеет соответствующей
конструкции catch, интерпретатор анализирует следующий внешний блок кода и проверяет, связан ли с ним обработчик исключений. Это продолжается до тех
пор, пока обработчик не будет найден. Если исключение генерируется в функции, не содержащей инструкции try/catch/finally, 
предназначенной для его обработки, то исключение распространяется на код, вызвавший функцию. Так исключения распространяются по лексической структуре методов JavaScript
вверх по стеку вызовов. Если обработчик исключения так и не будет найден, исключение рассматривается как ошибка и о ней сообщается пользователю.</p>
	</li>
	<li>
		<strong>Инструкция try/catch/finally</strong>
		<p>Инструкция try/catch/finally реализует механизм обработки исключений в JavaScript. Конструкция try в этой инструкции просто определяет блок кода, в котором обрабатываются исключения. За блоком try следует конструкция catch
с блоком инструкций, вызываемых, когда где-либо в блоке try возникает исключение. За конструкцией catch следует блок finally, содержащий код зачистки,
который гарантированно выполняется независимо от того, что происходит в блоке try. И блок catch, и блок finally не являются обязательными, однако после
блока try должен обязательно присутствовать хотя бы один из них. Блоки try,
catch и finally начинаются и заканчиваются фигурными скобками. Это обязательная часть синтаксиса и она не может быть опущена, даже если между ними
содержится только одна инструкция. <br />
<code>try {</code>
<br />
<code>// ...</code>
<br />
<code>} catch(error) {</code>
<br />
<code>// ...</code>
<br />
<code>} finally {</code>
<br />
<code>// ...</code>
<br />
<code>}</code>

<br />try - Обычно этот код без сбоев работает от начала до конца. Но в какой-то момент в нем может генерироваться исключение либо непосредственно с помощью инструкции throw, либо косвенно вызовом метода, генерирующего исключение.
<br />catch - Инструкции в этом блоке выполняются тогда и только тогда, когда в блоке try генерируется исключение. Эти инструкции могут использовать локальную переменную e, ссылающуюся на объект Error или на другое значение, указанное в инструкции throw. Этот блок может либо каким-либо образом обработать исключение, либо проигнорировать его, делая что-то другое, либо заново сгенерировать исключение с помощью инструкции throw.
<br />finally - Этот блок содержит инструкции, которые выполняются всегда, независимо от того,
что произошло в блоке try. Они выполняются, если блок try прерван
1) нормальным образом, достигнув конца блока
2) из-за инструкции break, continue или return
3) с исключением, обработанным приведенным ранее блоком catch
4) с неперехваченным исключением, которое продолжает свое распространение на более высокие уровни
</p>
	</li>
</ul>
