<h3>Операторы</h3>
<p><strong>Арифметические операторы</strong></p>
<ul>
	<li>
		<strong>Сложение (+)</strong>
		<p>Оператор «плюс» складывает числовые операнды или выполняет конкатенацию строк. Если одним из операндов является строка, 
другой операнд преобразуется в строку и выполняется конкатенация. Операнды-объекты преобразуются в числа или строки, 
которые могут быть сложены или конкатенированы.
Преобразование выполняется с помощью методов valueOf() и/или toString().</p>
	</li>
	<li>
		<strong>Вычитание (-)</strong>
		<p>Когда «минус» используется в качестве двухместного оператора, он выполняет вычитание второго операнда из первого. 
Если указаны нечисловые операнды, то оператор пытается преобразовать их в числа.</p>
	</li>
	<li>
		<strong>Умножение (*)</strong>
		<p>Оператор * умножает два своих операнда. Нечисловые операнды он пытается
преобразовать в числа.</p>
	</li>
	<li>
		<strong>Деление (/)</strong>
		<p>Оператор / делит первый операнд на второй. Нечисловые операнды он пытается преобразовать в числа. В JavaScript все числа вещественные, 
поэтому результатом любого деления является значение с плавающей точкой. Операция 5/2 дает 2.5, а не 2. 
Результат деления на ноль – плюс или минус бесконечность, а 0/0 дает NaN.</p>
	</li>
	<li>
		<strong>Деление по модулю (%)</strong>
		<p>Оператор % вычисляет остаток, получаемый при целочисленном делении первого операнда на второй. 
Если заданы нечисловые операнды, то оператор пытается преобразовать их в числа. 
Знак результата совпадает со знаком первого операнда, например 5 % 2 дает 1. Оператор деления по модулю обычно применяется к целым операндам, 
но работает и для вещественных значений. Например, -4.3 % 2.1 дает результат -0.1.</p>
	</li>
	<li>
		<strong>Унарный минус (-)</strong>
		<p>Когда минус используется в качестве унарного оператора, он указывается перед одиночным операндом и выполняет унарную операцию смены знака.
Другими словами, он преобразует положительное значение в отрицательное,
и наоборот. Если операнд не является числом, этот оператор пытается преобразовать его в число.</p>
	</li>
	<li>
		<strong>Унарный плюс (+)</strong>
		<p>Для симметрии с оператором «унарный минус» в JavaScript также имеется
оператор «унарный плюс». При помощи этого оператора можно явно задать
знак числовых литералов, если вы считаете, что это сделает текст программы
более понятным:
var p = +1000000;
В таком коде оператор «плюс» ничего не делает; результатом его работы является значение его аргумента. 
Однако нечисловые аргументы он преобразует в числа. Если аргумент не может быть преобразован, возвращается NaN.
</p>
	</li>
	<li>
		<strong>Инкремент (++)</strong>
		<p>Этот оператор инкрементирует (т. е. увеличивает на единицу) свой единственный операнд, который должен быть переменной, элементом массива или
свойством объекта. Если значение этой переменной, элемента массива или
свойства не является числом, оператор сначала пытается преобразовать его в число. 
Точное поведение этого оператора зависит от его положения по отношению к операнду. 
Если поставить его перед операндом (префиксный оператор инкремента), то к операнду прибавляется 1, а результатом является увеличенное значение операнда. 
Если же он размещается после операнда (постфиксный оператор инкремента), то к операнду прибавляется 1, 
однако результатом является первоначальное значение операнда. Если увеличиваемое
значение не является числом, оно в процессе вычисления преобразуется
в число. Например, следующий код делает переменные i и j равными 2: <br />
<code>i = 1;</code><br />
<code>j = ++i;</code><br />
А этот устанавливает i в 2, а j в 1: <br />
<code>i = 1;</code><br />
<code>j = i++;</code><br />
</p>
	</li>
	<li>
		<strong>Декремент (--)</strong>
		<p>Этот оператор декрементирует (т. е. уменьшает на 1) свой единственный числовой операнд, который может представлять собой переменную, элемент
массива или свойство объекта. Если значение этой переменной, элемента или
свойства не является числом, оператор сначала пытается преобразовать его
в число. Как и для оператора ++, точное поведение оператора -- зависит от его
положения относительно операнда. Будучи поставленным перед операндом,
он уменьшает операнд и возвращает уменьшенное значение, после операнда –
уменьшает операнд, но возвращает первоначальное значение.</p>
	</li>
</ul>
<p><strong>Строковые операторы</strong></p>
<p>Оператор + выполняет конкатенацию двух строковых операндов. Другими словами, 
создает новую строку, состоящую из первой строки, за которой следует
вторая строка. Так, следующее выражение равно строке "hello there":
<br />
<code>"hello" + " " + "there"</code>
<br />

Следующие инструкции дают в результате строку "22":
<br /><code>a = "2"; b = "2";</code>
<br /><code>c = a + b;</code><br />
Операторы <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> и <code>&gt;=</code> сравнивают две строки и определяют, в каком порядке
они следуют друг за другом. Сравнение основано на алфавитном порядке, который базируется на используемой в JavaScript кодировке Unicode. 
В этой кодировке все прописные буквы латинского алфавита идут раньше, чем все строчные буквы (прописные «меньше» строчных), что может приводить к неожиданным результатам.

Оператор + особенный, поскольку дает приоритет строковым операндам перед
числовыми. Если один из операндов оператора + представляет собой строку (или объект), 
то другой операнд преобразуется в строку (или оба операнда преобразуются в строки) и операнды конкатенируются, а не складываются. 
Например:
<br />
<code>1 + 2 // Сложение. Результат равен 3.</code>
<br />
<code>"1" + "2" // Конкатенация. Результат равен "12".</code>
<br />
<code>"1" + 2 // Конкатенация; 2 преобразуется в "2". Результат равен "12".</code>
<br />
<code>11 < 3 // Численное сравнение. Результат равен false.</code>
<br />
<code>"11" < "3" // Строковое сравнение. Результат равен true.</code>
</p>
<p><strong>Логические операторы</strong></p>
<ul>
	<li>
		<strong>Логическое И (&&)</strong>
		<p>При использовании с логическими операндами оператор && выполняет операцию
логического И над двумя значениями: он возвращает true тогда и только тогда,
когда первый и второй операнды равны true. Если один или оба операнда равны
false, оператор возвращает false.</p>
	</li>
	<li>
		<strong>Логическое ИЛИ (||)</strong>
		<p>При использовании с логическими операндами оператор || выполняет операцию
«логическое ИЛИ» над двумя значениями: он возвращает true, если первый или
второй операнд (или оба операнда) равен true. Если оба операнда равны false, он
возвращает false.</p>
	</li>
	<li>
		<strong>Логическое НЕ (!)</strong>
		<p>Оператор инвертирует значение своего операнда. Так, если переменная a имеет значение true 
(или представляет собой значение, преобразуемое в true), то выражение !a имеет значение false. И если выражение p && q равно
false (или значению, преобразуемому в false), то выражение !(p && q) равно true.
Обратите внимание, что можно преобразовать значение любого типа в логическое, применив этот оператор дважды: !!x.</p>
	</li>
</ul>
<p><strong>Операторы присваивания</strong></p>
<p>Для присваивания значения переменной в JavaScript используется символ =. 
Например: <code>i = 0</code><br />
В JavaScript можно не рассматривать такую строку как выражение, которое
имеет результат, но это действительно выражение и формально знак = представляет собой оператор.
Левым операндом оператора = должна быть переменная, элемент массива или
свойство объекта. Правым операндом может быть любое значение любого типа.
Значением оператора присваивания является значение правого операнда.
Поскольку = представляет собой оператор, его можно включать в более сложные
выражения. Так, в одном выражении можно совместить операции присваивания и проверки значения:
<code>(a = b) == 0</code><br />
<br />
<strong>Присваивание с операцией</strong><br />

<table>
	<tr>
		<th>Операция</th>
		<th>Пример</th>
		<th>Значение</th>
	</tr>
	<tr>
		<td>+=</td>
		<td>a += b</td>
		<td>a = a + b</td>
	</tr>
	<tr>
		<td>-=</td>
		<td>a -= b</td>
		<td>a = a – b</td>
	</tr>
	<tr>
		<td>*=</td>
		<td>a *= b</td>
		<td>a = a * b</td>
	</tr>
	<tr>
		<td>/=</td>
		<td>a /= b</td>
		<td>a = a / b</td>
	</tr>
	<tr>
		<td>%=</td>
		<td>a %= b</td>
		<td>a = a % b</td>
	</tr>
</table>
</p>
<p><strong>Оператор «запятая»</strong></p>
<p>Оператор «запятая» (,) очень прост. Он вычисляет свой левый операнд, вычисляет свой правый операнд и возвращает значение правого операнда, 
т. е. следующая строка <code>i=0, j=1, k=2;</code> возвращает значение 2 и практически эквивалентна записи:
<br />
<code>i = 0;</code>
<br />
<code>j = 1;</code>
<br />
<code>k = 2;</code>
</p>
<p><strong>Операторы доступа к массивам и объектам</strong></p>
<p>Можно обращаться к элементам массива посредством
квадратных скобок ([]), а к элементам объекта – посредством точки (.). И квадратные скобки, и точка рассматриваются в JavaScript как операторы.</p>
<p><strong>Оператор вызова функции</strong></p>
<p>Оператор () предназначен в JavaScript для вызова функций. Этот оператор не имеет фиксированного количества операндов.
Первый операнд – это всегда имя функции или выражение, ссылающееся на
функцию. За ним следует левая скобка и любое количество дополнительных операндов, которые могут быть произвольными выражениями, отделенными друг
от друга запятыми. За последним операндом следует правая скобка. Оператор ()
вычисляет все свои операнды и затем вызывает функцию, заданную первым операндом, используя в качестве аргументов оставшиеся операнды. Например:
<code>alert("Welcome " + name)</code></p>
<p><strong>Операторы равенства</strong></p>
<ul>
	<li>
		<strong>Равенство (==) и идентичность (===)</strong>
		<p>Операторы == и === проверяют две величины на совпадение, руководствуясь двумя разными определениями совпадения. Оба оператора принимают операнды
любого типа и возвращают true, если их операнды совпадают, и false, если они
различны. Оператор ===, известный как оператор идентичности, проверяет два
операнда на «идентичность», руководствуясь строгим определением совпадения. Оператор == известен как оператор равенства, он проверяет, равны ли два
его операнда в соответствии с менее строгим определением совпадения, допускающим преобразования типов.</p>
	</li>
	<li>
		<strong>Неравенство (!=) и неидентичность (!==)</strong>
		<p>Операторы != и !== выполняют проверки, в точности противоположные операторам == и ===. Оператор != возвращает false, если два значения равны друг другу,
и true в противном случае. Оператор неидентичности !== возвращает false, если
два значения идентичны друг другу, и true – в противном случае.</p>
	</li>
</ul>
<p><strong>Операторы сравнения</strong></p>
<ul>
	<li>
		<strong>Меньше (&lt;)</strong>
		<p>Результат оператора &lt; равен true, если первый операнд меньше, чем второй
операнд; в противном случае он равен false.</p>
	</li>
	<li>
		<strong>Больше (&gt;)</strong>
		<p>Результат оператора &gt; равен true, если его первый операнд больше, чем второй операнд; в противном случае он равен false.</p>
	</li>
	<li>
		<strong>Меньше или равно (&lt;=)</strong>
		<p>Результатом оператора &lt;= является true, если первый операнд меньше или равен второму операнду; в противном случае результат равен false.</p>
	</li>
	<li>
		<strong>Больше или равно (&gt;=)</strong>
		<p>Результат оператора &gt;= равен true, если его первый операнд больше второго
или равен ему; в противном случае он равен false.</p>
	</li>
</ul>
<p><strong>Оператор in</strong></p>
<p>Оператор in требует, чтобы левый операнд был строкой или мог быть преобразован в строку. Правым операндом должен быть объект (или массив). Результатом
оператора будет true, если левое значение представляет собой имя свойства объекта, указанного справа. Например:
<br />
<code>var obj = { x:1, y:1 }; // Определяем объект</code>
<br />
<code>var has_x = "x" in obj; // Равно true</code></p>
<p><strong>Оператор instanceof</strong></p>
<p>Оператор instanceof требует, чтобы левым операндом был объект, а правым –
имя класса объектов. Результатом оператора будет true, если объект, указанный
слева, представляет собой экземпляр класса, указанного справа; в противном
случае результатом будет false. В главе 9 мы увидим, что в JavaScript классы
объектов определяются инициализировавшей их функцией-конструктором.
Следовательно, правый операнд instanceof должен быть именем функции-конструктора. 
Обратите внимание: все объекты представляют собой экземпляры класса Object. 
Например:
<br />
<code>var d = new Date(); // Создаем новый объект с помощью конструктора Date()</code>
<br />
<code>d instanceof Date; // Равно true; объект d был создан с помощью функции Date()</code>
<br />

Если левый операнд instanceof не является объектом или если правый операнд –
это объект, не имеющий функции-конструктора, instanceof возвращает false.
Но если правый операнд вообще не является объектом, возвращается ошибка</p>
<p><strong>Условный оператор (?:)</strong></p>
<p>Условный оператор – это единственный тернарный оператор (с тремя операндами) в JavaScript и иногда он так и называется – «тернарный оператор». 
Этот оператор обычно записывается как ?:, хотя в текстах программ он выглядит по-другому. 
Он имеет три операнда, первый идет перед ?, второй – между ? и :, третий – после :. Используется он следующим образом: <br />
<code>x > 0 ? x*y : -x*y</code></p>
<p><strong>Оператор typeof</strong></p>
<p>Унарный оператор typeof помещается перед единственным операндом, который
может иметь любой тип. Его значение представляет собой строку, указывающую
тип данных операнда.
Результатом оператора typeof будет строка "number", "string" или "boolean", если
его операндом является число, строка или логическое значение соответственно.</p>
<p><strong>Оператор создания объекта (new)</strong></p>
<p>Оператор new создает новый объект и вызывает функцию-конструктор для его
инициализации. Это унарный оператор, указываемый перед вызовом конструктора и имеющий следующий синтаксис:
<br /><code>new конструктор(аргументы)</code><br />
Здесь конструктор – это выражение, результатом которого является функция-конструктор, и за ним должны следовать ноль или более аргументов, 
разделенных запятыми и заключенных в круглые скобки. Как особый случай и только
для оператора new JavaScript упрощает грамматику, допуская отсутствие скобок, если у функции нет аргументов. Вот несколько примеров использования
оператора new: <br />
<code>o = new Object; // Здесь необязательные скобки опущены</code>
<br />
<code>d = new Date(); // Возвращает объект Date, содержащий текущее время</code>
<br />
<code>c = new Rectangle(3.0, 4.0, 1.5, 2.75); // Создает объект класса Rectangle</code>
<br />
<code>obj[i] = new constructors[i]();</code>
<br />

Оператор new сначала создает новый объект с неопределенными свойствами, а затем вызывает заданную функцию-конструктор, 
передавая ей указанные аргументы, а также только что созданный объект в качестве значения ключевого
слова this. С помощью этого слова функция-конструктор может инициализировать новый объект любым необходимым образом.</p>
<p><strong>Оператор delete</strong></p>
<p>Унарный оператор delete выполняет попытку удалить свойство объекта, элемент массива или переменную, указанную в его операнде.1 Он возвращает true,
если удаление прошло успешно, и false в противном случае. Не все переменные
и свойства могут быть удалены – некоторые встроенные свойства из базового
и клиентского языков JavaScript устойчивы к операции удаления. Кроме того,
не могут быть удалены переменные, определенные пользователем с помощью
инструкции var.
<br />
<code>var o = {x:1, y:2}; // Определяем переменную; инициализируем ее объектом</code>
<br />
<code>delete o.x; // Удаляем одно из свойств объекта; возвращает true</code>
<br />
<code>typeof o.x; // Свойство не существует; возвращает "undefined"</code>
<br />
<code>delete o.x; // Удаляем несуществующее свойство; возвращает true</code>
<br />
<code>delete o; // Объявленную переменную удалить нельзя; возвращает false</code>
<br />
<code>delete 1; // Нельзя удалить целое; возвращает true</code>
<br />
<code>x = 1; // Неявно объявляем переменную без ключевого слова var</code>
<br />
<code>delete x; // Этот вид переменных можно удалять; возвращает true</code>
<br />
<code>x; // Ошибка времени выполнения: x не определено</code>
</p>
<p><strong>Оператор void</strong></p>
<p>Унарный оператор void указывается перед своим единственным операндом, тип
которого может быть любым. Действие этого оператора необычно: он отбрасывает значение операнда и возвращает undefined. Чаще всего этот оператор 
применяется на стороне клиента в URL-адресе с признаком псевдопротокола javascript:,
где позволяет вычислять выражение ради его побочных действий, не отображая
в броузере вычисленное значение.
Например, можно использовать оператор void в HTML-теге:
<br /><code>&lt;a href="javascript:void(document.body.style.backgroundColor='green');"&gt;Зеленый фон&lt;/a&gt;</code>
<br /><code>&lt;a href="javascript:void window.open();"&gt;Открыть новое окно&lt;/a&gt;</code></p>