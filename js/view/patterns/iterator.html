<h3>The Iterator Pattern</h3>
<p>Шаблон
итератора применяется, когда имеется объект, содержащий
совокупность данных. Эти данные могут храниться в виде сложной
структуры, а вам необходимо обеспечить удобный доступ к каждому
элементу этой структуры. Пользователи вашего объекта не обязаны
знать, как организованы ваши данные, – им необходим доступ к от
дельным элементам.</p>
<p>Объект, реализующий шаблон
итератора, должен предоставить метод
next(). При последующем обращении метод next() должен вернуть сле
дующий элемент, и только вам решать, что означает понятие «следующий» для вашей конкретной структуры данных.</p>
<p>То есть паттерн позволяет перебирать элементы коллекции, не зная, как реализована коллекция. Применение паттерна позволяет передать ответственность перебора элементов от объекта коллекции объекту итератора. Это обстоятельство не только упрощает интерфейс, но и избавляет коллекцию от посторонних обязанностей (ее главной задачей является управление объектами, а не перебор). </p>
<p>Применение: идея заключается в том, чтоб возложить ответственность за обход составного объекта на отдельный объект-итератор. Другими словами, у вас может быть объект класса List и объект класса ListIterator. Класс List отвечает за работу с элементами списка (реализует методы add, remove, count), а класс ListIterator отвечает за обход списка (реализует методы next, previous, getCurrentItem, isDone).
Если мы вынесем алгоритм обхода структуры за пределы самой структуры, тогда мы сможем добавлять новые алгоритмы обхода, при этом не изменяя саму структуру (класс List). Например, для того, чтоб добавить возможность обхода четных и нечетных элементов структуры, мы создаем 2 класса: EvenListIterator и OddListIterator.</p>
